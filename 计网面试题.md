## 一、HTTP与HTTPS有哪些区别？
> HTTPS 要比 HTTP多了secure安全性这个概念，实际上，HTTPS并不是一个新的应用层协议，他其实就是HTTP+TLS/SSL协议
> 组合而成，而安全性的保证是SSL/TSL所做的工作。
> 
**SSL**（安全套接层 Secure Sockets Layer）
**TSL**（传输层安全 Transport Layer Security）
**HTTPS就是身披了一层SSL的HTTP**
![](http://img-repo.poetries.top/images/20210409105003.png)

HTTP与HTTPS的区别？
- HTTP是明文传输协议，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP安全。
- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO。
- HTTPS标准端口443，HTTP标准端口80.
- HTTPS需要用到SSL证书，而HTTP不用。

两点HTTPS主要作用

==1.对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全==
==2.对网站服务器进行真实身份验证==

## 二、TCP怎么保证可靠传输？
[TCP滑动窗口和拥塞窗口](https://www.cnblogs.com/diegodu/p/4538897.html)

**TCP协议保证数据传输可靠性的方式主要有**：
（校序重流拥）

*校验和*
发送的数据包的二进制相加然后取反，目的是检测数据在传输中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。
*确认应答+序列号*
TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
*超时重传*
当TCP发出一个段后，他启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
*流量控制*
TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方得数据，能提示发送方降低发送的速率，防止包丢失。TCP
使用的流量控制协议是可变大小的滑动窗口协议。
接收方有即时窗口（滑动窗口），随ACK报文发送。
*拥塞控制*
当网络拥塞时，减少数据的发送。
发送方有拥塞窗口，发送数据前比对接收方发过来的即时窗口，取小
慢启动、拥塞避免、拥塞发送、快速恢复

应用数据被分割成TCP认为最适合发送的数据块
TCP的接收端会丢弃重复的数据

### 1.校验和
计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。
发送方：在发送之前计算校验和，并进行校验和的填充。
接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行对比
![](http://dl2.iteye.com/upload/attachment/0130/5454/6b8138a2-e6d6-3e2b-af10-cac9dabbf38e.png)
tips:如果接收方对比校验和与发送方的不一致，那么数据一定传输有误。但是如果接收方对比校验和与发送方一致，数据不一定传输成功。

### 2.确认应答与序列号
序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。
确认应答：TCP传输的过程中，每次接收方接收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文中带有
对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。
![](http://dl2.iteye.com/upload/attachment/0130/5456/ede3ff8a-ad3a-3a4a-bdbb-443a9691cdba.png)
序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。

### 3.超时重传
在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发完数据后，迟迟没有等到接收方的ACK报文，
这该怎么办呢？没有收到报文的原因是什么呢？

首先，发送方没有接收到响应的ACK报文原因可能有两点：
a、数据在传输过程中由于网络原因等直接全体丢包，接收方没有收到
b、接收方接收到了响应数据，但是发送的ACK报文响应却由于网路原因丢包了

TCP在解决这一问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有
接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才的第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是
第二个原因，接受方发现接受的数据已经存在（判断的依据就是序列号所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。


那么发送方发发送完毕后等待的时间是多少呢？如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。
如何权衡？

由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。

TIPS：超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，扔未响应，那么等待2`*`500ms的时间后，
再次重传。以一个指数的形式增长。累积到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。

### 4.连接管理
连接管理就是三次握手与四次挥手的过程。保证可靠地连接，就是保证可靠性的前提。

### 4.1流量控制
接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的接受缓存区很快的充满了。此时如果发送端仍旧发送数据，
那么接下来发送的数据包都会丢失，继而导致丢包的一系列连锁反应，超时重传等。而TCP根据接收端对数据的处理能力，决定发送端的发送数据，这个机制就是流量控制。

在TCP协议的报头信息当中，有一个16位字段的窗口大小。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小
。这个数字越大，证明接受端接受缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。
而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。
并定期的向接受端发送窗口探测数据段，让接受端把窗口大小告诉发送端。

![](http://dl2.iteye.com/upload/attachment/0130/5458/645c4330-0cef-3abd-a156-3dded35a6859.png)

TIPS:16位的窗口大小能表示65535个字节(64k)，但是TCP的窗口大小最大并不是64k。在TCP首部中40个字节的选项中还包含了
一个窗口扩大因子M,实际的窗口大小就是16位窗口字段的值左移M位。每移一位，扩大两倍。

### 4.2拥塞控制

TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候
就很拥堵，如果给网络中扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。

索引TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。
发送刚开始定义拥塞窗口为1，每次收到ACK应答，拥塞窗口加一。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小对比，取比较小的值作为实际发送的窗口。

拥塞窗口的增长是指数级别的。慢启动的机制只是在说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使用拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值
，当拥塞敞口大小超过阈值是我，不能在按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，
发生超时重传时，慢启动的阈值会为原来的一半(这里的原来指的是发生网络拥塞时拥塞窗口的大小)，同时拥塞窗口重置为1.
![](http://dl2.iteye.com/upload/attachment/0130/5460/954c289d-84e1-35e8-8050-b6f01c35882d.png)

拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。

拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4)快速恢复。

拥塞避免

当拥塞窗口>=阈值时，就会进入“拥塞避免算法”
这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。是一个线性上升的算法。

拥塞发生
当发生超时重传后，阈值会变成拥塞窗口的一半

快速恢复

## 三、TCP与UDP在网络协议的哪一层，他们之间有什么区别？
位于传输层

首先UDP协议是面向无连接的，也就是说不需要在正式传输数据之前先连接起双方。然后UDP协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，
并且UDP协议也没有任何控制流量的算法，总的来说UDP相较于TCP更加的轻便

### 1.面向无连接的
- 首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，想发数据就开始发送了。
- 并且也只是数据报文的搬运工，不会对数据报文进行任何的拆分和拼接操作
### 2.不可靠性
- 首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠
- 并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据后也不会关心对方是否已经正确接受到数据了
- 再者网络环境时好时坏，但是UDP没有拥塞控制，一直会为恒定的速度发送数据。即使网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景就需要UDP而不是TCP

### 3.高效
- 虽然UDP协议不是那么可靠，但是正因为它不是那么的可靠，所以也就没有TCP那么复杂了，需要保证数据不丢失且有序到达。
- 因此UDP的头部开销小，只有八个字节，相比于TCP的至少二十个字节要少得多，在传输数据报文时是很高效的

### 4.传输方式
- UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。

### 5.适合使用的场景
UDP虽然对比TCP有很多缺点，但是正因为这些缺点造就了他的高效的特性，在很多实时性要求高的地方都可以看到UDP的身影。

## 四、从输入 URL 到展现页面的全过程
**1.URL解析**

**2.缓存检查**

**3.DNS解析**

**4.TCP三次握手建立连接**

**5.数据传输**

**6.TCP四次挥手断开连接**

**7.页面渲染**

[](http://interview.poetries.top/days/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%B1%87%E6%80%BB)

## 五、简述TCP三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？

**三次握手**

- 第一次握手：客户端发送SYN给客户端，进入SYN_SEND状态
- 第二次握手：服务端收到客户端发送过来的SYN，返回确认号ACK，并一起返回一个SYN，进入SYN_RECV状态
- 第三次握手：客户端收到服务端传送过来的SYN+ACK后，给客户端发送一个ACK。进入ESTABLISED状态。
- 当服务端收到来自客户端的ACK后，也进入ESTABLISHED状态。

**为什么需要三次握手呢？**
原因是TCP提供的是可靠地数据传输
- 考虑一次的问题，首先TCP是面向连接，一次握手肯定建立不了连接，因为客户机给服务器发出请求信息却没有收到回应，客户机是没法判定是否发送成功然后建立连接的。
- 再看两次的情况，假设只有两次握手，当A想建立连接时发送一个SYN，然后等待ACK，结果这个SYN因为网络的问题没有及时到达B，所以A在一段时间内没有收到ACK后，在发送一个SYN，这次B顺利收到，接着A也收到ACK，这是A发送的第一个SYN到达了B，对于B来说这是一个新的连接请求，然后B又为这个连接申请资源，返回ACK，然而这个SYN是个无效的请求，A收到这个SYN的ACK后也并不会理会它，而B却不知道，B会一直为这个连接维持着资源，造成资源的浪费。

**三次握手就没有毛病了？？**
*是的。两次握手的问题在于服务器端不知道一个SYN是否是无效的，而第三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，客户端会认为这个SYN也是无效的，释放相关资源。*
==但是这时有个问题就是客户端完成第二次握手便认为连接已经建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果Client端向SERVER写数据，Server端将以RST包响应，这时便感知到Server的错误。

**总之，三次握手可以保证任何一次握手失败都是可感知的，不会浪费资源**

:happy:

**四次挥手**
- 第一次挥手：主动方向被动方发送一个FIN报文，之后主动方进入FIN_WAIT1状态
- 第二次挥手：被动方收到主动方发过来的FIN后，会返回一个ACK确认。
- 第三次挥手：当被动方没有传输的数据后，向主动方发送一个FIN报文。
- 第四次挥手：主动方收到被动方发来的FIN报文后，给被动方返回一个确认序列号ACK
- 主动方等待2MSL（最大报文生存时间）后，断开连接

**TIME_WAIT产生的原因以及TIME_WAIT（2MSL）的原因**
- 1.可靠地实现TCP全双工连接的终止

我们必须假象网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时没有收到ACK报文，而重发FIN报文，client必须维护这条连接的状态（保持TIME_WAIT，具体而言，就是这条TCP连接对应的（local_ip,local_port）资源不能被立即释放或重新分配），以便可以重发丢失的ACK，如果主动关闭端不维持TIME_WAIT状态，而是处于CLOSED状态，主动关闭端将会响应一个RST，结果server认为发生错误，导致服务器端不能正常关闭连接。**所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。**所以当客户端等待2MSL后，没有收到服务端的ACK报文后，他就知道服务端已收到了ACK报文，所以客户端此时才关闭自己的连接。

- 2.允许老的重复分节在网络中消逝

防止已失效的连接请求报文段出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。






