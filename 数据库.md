## 一、MySQL为什么使用B+树来做索引，对比B树他的优点和缺点是什么？
- B树（平衡多路搜索树）
  - 图示
  ![](https://img-blog.csdnimg.cn/20210217120413350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.每个节点可有多颗子树
    - 2.每个非叶子节点有n个key，并且有n+1棵子树（子树数量比key数量多1）
    - 3.每个节点中key都是从小到大排序的
    - 4.最左子树上的值都小于最左key的值，最优子树上的值都小于最右key的值，中间子树的值则位于相邻两个节点的值之间
    - 5.所有叶子节点都具有相同的深度
- B+树
  - 图示
    ![](https://img-blog.csdnimg.cn/20210217120441387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.子树与key的数量相同，节点的关键字为子树中的最大值
    - 2.非叶子节点不保存数据，仅用作索引，叶子节点保存全部数据
    - 3.所有叶子节点构成一个链表

**局部性原理与磁盘预读**
- 局部性原理

当一个数据被用到时，其附近的数据通常也会被用到

- 磁盘预读

磁盘不是按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置向后读取一定长度放到内存

预读的长度一般为页（页的大小一般为64k）的整数倍

**mysql为什么使用B+树而不是B树作为索引？**
- 由于mysql通常将数据存放在磁盘中，读取数据就会产生磁盘的IO消耗。而B+树的非叶子节点中不保存数据，B树中的非叶子节点会保存数据，通常一个节点大小会设置为磁盘页大小，这样B+树每个节点可放更多的key,B树则更少。这样就造成了，B树的高度会比B+树更高，从而产生更多的磁盘IO消耗。
- B+树叶子节点构成链表，更利于范围查找和排序。而B树进行范围查找和排序则要对树进行递归遍历。


**B树和B+树比较**

  - B+树层级更少，查找更快
  - B+树查询速度稳定：由于B+树所有数据都存储在叶子节点，所以查询任意数据的次数都是树的高度h
  - B+树有利于范围查找
  - B+树全节点遍历更快：所有叶子节点构成链表，全节点扫描，只需要遍历这个链表即可
  - B树优点：如果在B树中查找的数据离根节点近，由于B树节点中保存有数据，那么这时查询速度比B+树快。

**为什么不使用红黑树（自平衡二叉搜索树）？**

如果使用红黑树，会使树的高度更高，增加IO消耗

**为什么不适用哈希表？**

哈希表对于范围查找和排序效率低，但对于单个数据的查询效率高

## 二、简述MySQL常见的索引类型，介绍一下覆盖索引

**mysql索引主要有两种结构：B+Tree索引和Hash索引**

**Hash索引**

MySQL中，只有memory(memory表只存在在内存中，断电会消失，适用于临时表）存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据的索引以Hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为是Hash结构，每个建只对应一个值，而且是散列的方式分布。所以他并不支持范围查找和排序等功能。

**B+Tree索引**

B+Tree索引是MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎模式的索引类型。相对于Hash索引，B+树在查找单条记录的速度上比不上Hash索引，但是因为更适合范围查询和排序等操作，所以更收客户欢迎。

***带顺序访问指针的B+Tree**

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。
这样做是为了提高区间查询效率，例如查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大地提高了区间查询效率。

***大大减小磁盘IO消耗***
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次IO就可以完全载入。

为了达到这个目的，在实际实现B+Tree还需要使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次IO

B+Tree中一次检索做多需要h-1次IO（根节点常驻内存），渐进复杂度为O(h)=O(log<sub>d</sub>N）。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率会差很多。

**1.选择索引的数据类型**
MySQL支持很多数据类型，选择合适的数据类型对性能有很大的影响。通常来说，可以遵循一下一些指导原则：

- （1）越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
- （2）简单的数据类型更好：整数类型比起字符串，处理开销更小，因为字符串更复杂。在MySQL中尽量用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
- （3）尽量避免NULL：应该指定列为NOTNUL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值

**2.选择主键类型**


==MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引==

PRIMARY KEY（主键索引） ALTER TABLE `table_name` ADD PRIMARY KEY(`col`)

UNIQUE(唯一索引） ALTER TABLE `table_name` ADD UNIQUE(`col`)

INDEX(普通索引） ALTER TABLLE `table_name` ADD INDEX index_name(`col`)

FULLTEXT(全文索引） ALTER TABLE `table_name` ADD FULLTEXT(`col`)

组合索引 ALTER TABLE `table_name` ADD INDEX index_name(`col1`,`col2`,`col3`)

==Mysql各种索引区别==

普通索引：最基本的索引，没有任何限制

唯一索引：与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值

主键索引：它是一种特殊的唯一索引，不允许含有空值

全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时耗空间

联合索引：为了更多地提高MySQL效率可建立组合索引，遵循“最左前缀”原则。创建组合索引时应该将最常用（频率）做限制条件的列放在最左边，依次递减。

联合索引的好处：覆盖索引，这一点最重要的，众所周知非主键索引会先查到主键索引的值再从主键索引上拿到想要的值。但是覆盖索引可以直接在非主键索引上拿到相应的值，减少一次查询。


## 三、简述乐观锁以及悲观锁的区别以及使用场景

**1.概念上的区别**
乐观锁（Optimistic Locking）:顾名思义，对加锁持有一种乐观的态度，即先进行业务操作，不到最后一步不进行加锁，“乐观”的认为加锁一定会成功，在最后一步更新数据的时候再进行加锁。

悲观锁（Pessimistic Lock）：正如其名字一样，悲观锁对数据加锁持有一种悲观的态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能正真保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

**2.实现方式**

- 乐观锁：
  - version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

sql实现代码：
```sql
update table
set x=x+1, version=version+1
where id=#{id} and version=#{version}；
```
  -CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。
  
-悲观锁：
  
  是由数据库自己实现的，要用的时候，我们直接调用数据库的相关语句就可以了（原理：共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程），如行锁、读锁和写锁等，都是在操作之前加锁。
  
**3.使用场景**
乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的读取操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断地重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

悲观锁：比较适合写入操作比较频繁的场景，如果出现了大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

## 四、简述事务的四大特性

- 1.原子性（Atomicity）：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。
- 2.一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一个一致性状态。
- 3.隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发的事务是隔离的，并发执行的各个事务之间不能相互干扰。
- 4.持续性（Durability）：指一个事务一旦提交。他对数据库中数据的改变就应该是永久性的。接下来的操作或故障不应该对其执行结果有任何影响。


## 五、数据库的事物隔离级别有哪些？各有哪些优缺点？

事务的隔离级别有四个：分别是：
- 1.read uncommit 读未提交，这样可能会读到其他事务未提交的数据，也叫做脏读。
- 2.read commit 读已提交，会导致两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
- 3.repeatable read 可重复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
- serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。



## 六、MySQL有哪些常见的存储引擎？它们的区别是什么？
## 七、简述脏读和幻读的发生场景，InnoDB是如何解决幻读的？
## 八、聚簇索引和非聚簇索引有什么区别？
## 九、什么是数据库事物，MYSQL为什么会用InnnoDB作为默认选项
## 十、简述数据库中什么情况下进行分库，什么情况下进行分表？
## 十一、简述MySQL MVCC 的实现原理
MVCC叫做多版本并发控制，实际上就是保存了数据在某个节点的快照。我们每行数实际上隐藏了两列
## 十二、B+树叶子节点存储的是什么数据
## 十三、MySQL中InnoDB和MyISAM的区别是什么？
## 十四、数据库如何设计索引，如何查询优化？
## 十五、什么是SQL注入攻击？如何防止这类攻击？
## 十六、简述什么是最左匹配原则
## 十七、ACID靠什么来保证？
- 1.原子性由undo log 日志保证，他记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
- 2.一致性一般由代码层面来保证
- 3.隔离性由MVCC来保证
- 4.持续性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log 刷盘，宕机的时候可以从redo log 恢复。

## 一、Redis如何实现分布式锁？
## 二、简述Redis持久化中RDB以及AOF方案的优缺点
## 三、简述Redis中常见类型的底层数据结构
## 四、为什么Redis在单线程下能如此快？
## 五、简述Redis的线程模型以及底层架构设计
## 六、简述Redis的过期机制和内存淘汰策略
## 七、简述Redis的哨兵机制
## 八、简述redis中如何防止缓存雪崩和缓存击穿
## 九、简述Redis中跳表的应用以及优缺点
## 十、Redis有几种数据结构？Zset是如何实现的？
## 十一、简述Redis集群配置以及基础原理
