[深入理解MySQL索引之B+Tree](https://blog.csdn.net/b_x_p/article/details/86434387?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

## 一、MySQL为什么使用B+树来做索引，对比B树他的优点和缺点是什么？
- B树（平衡多路搜索树）
  - 图示
  ![](https://img-blog.csdnimg.cn/20210217120413350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.每个节点可有多颗子树
    - 2.每个非叶子节点有n个key，并且有n+1棵子树（子树数量比key数量多1）
    - 3.每个节点中key都是从小到大排序的
    - 4.最左子树上的值都小于最左key的值，最优子树上的值都小于最右key的值，中间子树的值则位于相邻两个节点的值之间
    - 5.所有叶子节点都具有相同的深度
- B+树
  - 图示
    ![](https://img-blog.csdnimg.cn/20210217120441387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.子树与key的数量相同，节点的关键字为子树中的最大值
    - 2.非叶子节点不保存数据，仅用作索引，叶子节点保存全部数据
    - 3.所有叶子节点构成一个链表

**局部性原理与磁盘预读**
- 局部性原理

当一个数据被用到时，其附近的数据通常也会被用到

- 磁盘预读

磁盘不是按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置向后读取一定长度放到内存

预读的长度一般为页（页的大小一般为64k）的整数倍

**mysql为什么使用B+树而不是B树作为索引？**
- 由于mysql通常将数据存放在磁盘中，读取数据就会产生磁盘的IO消耗。而B+树的非叶子节点中不保存数据，B树中的非叶子节点会保存数据，通常一个节点大小会设置为磁盘页大小，这样B+树每个节点可放更多的key,B树则更少。这样就造成了，B树的高度会比B+树更高，从而产生更多的磁盘IO消耗。
- B+树叶子节点构成链表，更利于范围查找和排序。而B树进行范围查找和排序则要对树进行递归遍历。


**B树和B+树比较**

  - B+树层级更少，查找更快
  - B+树查询速度稳定：由于B+树所有数据都存储在叶子节点，所以查询任意数据的次数都是树的高度h
  - B+树有利于范围查找
  - B+树全节点遍历更快：所有叶子节点构成链表，全节点扫描，只需要遍历这个链表即可
  - B树优点：如果在B树中查找的数据离根节点近，由于B树节点中保存有数据，那么这时查询速度比B+树快。

**为什么不使用红黑树（自平衡二叉搜索树）？**

如果使用红黑树，会使树的高度更高，增加IO消耗

**为什么不适用哈希表？**

哈希表对于范围查找和排序效率低，但对于单个数据的查询效率高

## 二、简述MySQL常见的索引类型，介绍一下覆盖索引

**mysql索引主要有两种结构：B+Tree索引和Hash索引**

**Hash索引**

MySQL中，只有memory(memory表只存在在内存中，断电会消失，适用于临时表）存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据的索引以Hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为是Hash结构，每个建只对应一个值，而且是散列的方式分布。所以他并不支持范围查找和排序等功能。

**B+Tree索引**

B+Tree索引是MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎模式的索引类型。相对于Hash索引，B+树在查找单条记录的速度上比不上Hash索引，但是因为更适合范围查询和排序等操作，所以更收客户欢迎。

***带顺序访问指针的B+Tree**

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。
这样做是为了提高区间查询效率，例如查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大地提高了区间查询效率。

***大大减小磁盘IO消耗***
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次IO就可以完全载入。

为了达到这个目的，在实际实现B+Tree还需要使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次IO

B+Tree中一次检索做多需要h-1次IO（根节点常驻内存），渐进复杂度为O(h)=O(log<sub>d</sub>N）。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率会差很多。

**1.选择索引的数据类型**
MySQL支持很多数据类型，选择合适的数据类型对性能有很大的影响。通常来说，可以遵循一下一些指导原则：

- （1）越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
- （2）简单的数据类型更好：整数类型比起字符串，处理开销更小，因为字符串更复杂。在MySQL中尽量用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
- （3）尽量避免NULL：应该指定列为NOTNUL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值

**2.选择主键类型**


==MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引==

PRIMARY KEY（主键索引） ALTER TABLE `table_name` ADD PRIMARY KEY(`col`)

UNIQUE(唯一索引） ALTER TABLE `table_name` ADD UNIQUE(`col`)

INDEX(普通索引） ALTER TABLLE `table_name` ADD INDEX index_name(`col`)

FULLTEXT(全文索引） ALTER TABLE `table_name` ADD FULLTEXT(`col`)

组合索引 ALTER TABLE `table_name` ADD INDEX index_name(`col1`,`col2`,`col3`)

==Mysql各种索引区别==

普通索引：最基本的索引，没有任何限制

唯一索引：与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值

主键索引：它是一种特殊的唯一索引，不允许含有空值

全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时耗空间

联合索引：为了更多地提高MySQL效率可建立组合索引，遵循“最左前缀”原则。创建组合索引时应该将最常用（频率）做限制条件的列放在最左边，依次递减。

联合索引的好处：覆盖索引，这一点最重要的，众所周知非主键索引会先查到主键索引的值再从主键索引上拿到想要的值。但是覆盖索引可以直接在非主键索引上拿到相应的值，减少一次查询。


## 三、简述乐观锁以及悲观锁的区别以及使用场景

**1.概念上的区别**
乐观锁（Optimistic Locking）:顾名思义，对加锁持有一种乐观的态度，即先进行业务操作，不到最后一步不进行加锁，“乐观”的认为加锁一定会成功，在最后一步更新数据的时候再进行加锁。

悲观锁（Pessimistic Lock）：正如其名字一样，悲观锁对数据加锁持有一种悲观的态度。因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能正真保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

**2.实现方式**

- 乐观锁：
  - version方式：一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

sql实现代码：
```sql
update table
set x=x+1, version=version+1
where id=#{id} and version=#{version}；
```
  -CAS操作方式：即compare and swap 或者 compare and set，涉及到三个操作数，数据所在的内存值，预期值，新值。当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试，一般情况下是一个自旋操作，即不断的重试。
  
-悲观锁：
  
  是由数据库自己实现的，要用的时候，我们直接调用数据库的相关语句就可以了（原理：共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程），如行锁、读锁和写锁等，都是在操作之前加锁。
  
**3.使用场景**
乐观锁：比较适合读取操作比较频繁的场景，如果出现大量的读取操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断地重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。

悲观锁：比较适合写入操作比较频繁的场景，如果出现了大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

## 四、简述事务的四大特性

- 1.原子性（Atomicity）：事务是数据库的逻辑工作单位，事务中包括的诸操作要么都做，要么都不做。
- 2.一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一个一致性状态。
- 3.隔离性（Isolation）：一个事务的执行不能被其他事务干扰。即一个事务的内部操作及使用的数据对其他并发的事务是隔离的，并发执行的各个事务之间不能相互干扰。
- 4.持续性（Durability）：指一个事务一旦提交。他对数据库中数据的改变就应该是永久性的。接下来的操作或故障不应该对其执行结果有任何影响。


## 五、数据库的事物隔离级别有哪些？各有哪些优缺点？

事务的隔离级别有四个：分别是：
- 1.read uncommit 读未提交，这样可能会读到其他事务未提交的数据，也叫做脏读。
- 2.read commit 读已提交，会导致两次读取结果不一致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。
- 3.repeatable read 可重复读，这是mysql的默认级别，就是每次读取结果都一样，但是有可能产生幻读。
- serializable 串行，一般是不会使用的，他会给每一行读取的数据加锁，会导致大量超时和锁竞争的问题。



## 六、MySQL有哪些常见的存储引擎？它们的区别是什么？

## 七、简述脏读和幻读的发生场景，InnoDB是如何解决幻读的？
## 八、聚簇索引和非聚簇索引有什么区别？
## 九、什么是数据库事物，MYSQL为什么会用InnnoDB作为默认选项
## 十、简述数据库中什么情况下进行分库，什么情况下进行分表？
## 十一、简述MySQL MVCC 的实现原理
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了多版本并发控制（MVCC）。不仅是MySQL，包括Oracle、PostgreSQL等其他数据库系统也都实现了MVCC，但各自的实现机制不尽相同，因为MVCC没有一个统一的实现标准。

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一刻看到的数据可能是不一样的。

前面说到不同的存储引擎的MVCC实现是不同的，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。下面我们通过InnoDB的简化版行为来说明MVCC是如何工作的。

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的版本号会作为事物的版本号，用来和查询到的每行记录的版本号进行比较。下面演示在 REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

- SELECT

    InnoDB会根据以下两个条件检查每行记录：
    - a.InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。
    - b.行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。
    
    只有符合上述两个条件的记录，才能返回作为查询结果。
    
- INSERT

    InnoDB为新插入的每一行保存当前系统版本号作为行版本号。
    
- DElETE

    InnoDB为删除的每一行保存当前系统版本号作为删除标识。
    
- UPDATE

    InnoDB为插入一行新纪录，保存当前系统版本号作为版本号，同时保存当前系统版本号到原来的行作为行删除标识
    
**保存这两个额外系统版本号，使大多数读操作可以不用加锁。这样设计使得读数据操作很简单，性能很好，而且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作**。

**MVCC只是在REPEATABLE READ 和READ COMMITED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITED 总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。**

## 十二、B+树叶子节点存储的是什么数据

首先MYSQL默认使用的存储引擎是InnoDB引擎，该引擎的索引结构默认为B+树；先说结论：B+树叶子节点存储的是主键KEY或者具体数据。分情况讨论：

**1.主键KEY的情况**

比如说user_name是个索引，当执行该SQL时```select * from user_info where `user_name`="xiaoming"```;

InnoDB就会建立user_name索引B+树，节点里存的是user_name这个KEY，叶子节点存储的数据是主键KEY。注意，叶子节点存储的是主键KEY！拿到主键KEY后，InnoDB才会去主键索引树里根据刚才在user_name索引树找到的主键KEY查找到对应的数据。

**2.具体数据的情况**

在执行 ```select * from user_info where id=5```这个语句时，InnoDB就会查询这颗主键ID索引B+树，找到对应的user_name='xxx'.

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9qM2dmaWNpY3lPdmF2Mk5uSGNuQzBFWUdpYkR5Um04Q0YxZnRZZUMwb1V0UGNrTWs5OEVqSExmVmdaajF2TGRpYzkzQmtkUEZISDlxeWljQ2ljaE9oSTVWcXY5US82NDA?x-oss-process=image/format,png)

**原因**

问题来了，为什么InnoDB只在主键索引树的叶子节点存储了具体数据，但是其他索引树却不存具体数据呢，而要多此一举先找到主键，再在主键索引树找到对应的数据呢？

其实原因很简单，因为InnoDB需要节省存储空间。一个表里可能有很多个索引，InnoDB都会给每个加了索引的字段生成索引树，如果每个字段的索引树都存储了具体数据，那么这个表的索引数据文件就变得非常巨大（数据极度冗余了）。从节约磁盘空间的角度来说，真的没有必要在每个字段索引树都存具体数据，通过这种看似“多此一举”的步骤，在牺牲较少查询的性能下节省了巨大的磁盘空间，这是非常值得的。

对比MyISAM（InnoDB之所以只在主键存具体数据的索引指针，是因为要支持事务，只要锁住主键索引就可以实现行级锁）？？？？

叶节点里存放的数据，是表中的数据还是副本中的数据？？（分情况：如果是聚簇索引，则保存的是实际数据，如果是非聚簇索引，则保存的是非聚簇索引的索引key，可以说是副本）？？？？

这块存在疑问

## 十三、MySQL中InnoDB和MyISAM的区别是什么？

1.InnoDB支持事务，MyISAM不支持事务
2.InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败
3.InnoDB是聚集索引，MyISAM是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此InnoDB必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚簇索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引跟辅助索引是独立的。
4.InnoDB不保存表的具体行数，执行```select count(*) from table```时需要全表扫描。而MyISAM用一个变量报存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快
5.InnoDB最小的锁粒度是行锁，MyISAM最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是MySQL将默认存储引擎从MyISAM改变成InnoDB的重要原因之一


## 十四、数据库如何设计索引，如何查询优化？


## 十五、什么是SQL注入攻击？如何防止这类攻击？
SQL注入攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串中，欺骗服务器执行恶意的SQL命令。在某些表单中，用户输入的内容直接用来构造（或影响）动态SQL命令，或作为存储过程的输入参数，这类表单特别容易受到SQL注入攻击。


## 十六、简述什么是最左匹配原则

## 十七、ACID靠什么来保证？
- 1.原子性由undo log 日志保证，他记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的sql
- 2.一致性一般由代码层面来保证
- 3.隔离性由MVCC来保证
- 4.持续性由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log 刷盘，宕机的时候可以从redo log 恢复。

## 一、Redis如何实现分布式锁？
## 二、简述Redis持久化中RDB以及AOF方案的优缺点
## 三、简述Redis中常见类型的底层数据结构
## 四、为什么Redis在单线程下能如此快？
## 五、简述Redis的线程模型以及底层架构设计
## 六、简述Redis的过期机制和内存淘汰策略
## 七、简述Redis的哨兵机制
## 八、简述redis中如何防止缓存雪崩和缓存击穿
## 九、简述Redis中跳表的应用以及优缺点
## 十、Redis有几种数据结构？Zset是如何实现的？
## 十一、简述Redis集群配置以及基础原理
