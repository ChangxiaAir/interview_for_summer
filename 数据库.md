## 一、MySQL为什么使用B+树来做索引，对比B树他的优点和缺点是什么？
- B树（平衡多路搜索树）
  - 图示
  ![](https://img-blog.csdnimg.cn/20210217120413350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.每个节点可有多颗子树
    - 2.每个非叶子节点有n个key，并且有n+1棵子树（子树数量比key数量多1）
    - 3.每个节点中key都是从小到大排序的
    - 4.最左子树上的值都小于最左key的值，最优子树上的值都小于最右key的值，中间子树的值则位于相邻两个节点的值之间
    - 5.所有叶子节点都具有相同的深度
- B+树
  - 图示
    ![](https://img-blog.csdnimg.cn/20210217120441387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhdGVyMTIyMzM=,size_16,color_FFFFFF,t_70#pic_center)
  - 特征
    - 1.子树与key的数量相同，节点的关键字为子树中的最大值
    - 2.非叶子节点不保存数据，仅用作索引，叶子节点保存全部数据
    - 3.所有叶子节点构成一个链表

**局部性原理与磁盘预读**
- 局部性原理

当一个数据被用到时，其附近的数据通常也会被用到

- 磁盘预读

磁盘不是按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置向后读取一定长度放到内存

预读的长度一般为页（页的大小一般为64k）的整数倍

**mysql为什么使用B+树而不是B树作为索引？**
- 由于mysql通常将数据存放在磁盘中，读取数据就会产生磁盘的IO消耗。而B+树的非叶子节点中不保存数据，B树中的非叶子节点会保存数据，通常一个节点大小会设置为磁盘页大小，这样B+树每个节点可放更多的key,B树则更少。这样就造成了，B树的高度会比B+树更高，从而产生更多的磁盘IO消耗。
- B+树叶子节点构成链表，更利于范围查找和排序。而B树进行范围查找和排序则要对树进行递归遍历。


**B树和B+树比较**

  - B+树层级更少，查找更快
  - B+树查询速度稳定：由于B+树所有数据都存储在叶子节点，所以查询任意数据的次数都是树的高度h
  - B+树有利于范围查找
  - B+树全节点遍历更快：所有叶子节点构成链表，全节点扫描，只需要遍历这个链表即可
  - B树优点：如果在B树中查找的数据离根节点近，由于B树节点中保存有数据，那么这时查询速度比B+树快。

**为什么不使用红黑树（自平衡二叉搜索树）？**

如果使用红黑树，会使树的高度更高，增加IO消耗

**为什么不适用哈希表？**

哈希表对于范围查找和排序效率低，但对于单个数据的查询效率高

## 二、简述MySQL常见的索引类型，介绍一下覆盖索引

**mysql索引主要有两种结构：B+Tree索引和Hash索引**

**Hash索引**

MySQL中，只有memory(memory表只存在在内存中，断电会消失，适用于临时表）存储引擎显示支持Hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B+Tree索引。Hash索引把数据的索引以Hash形式组织起来，因此当查找某一条记录的时候，速度非常快。但是因为是Hash结构，每个建只对应一个值，而且是散列的方式分布。所以他并不支持范围查找和排序等功能。

**B+Tree索引**

B+Tree索引是MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎模式的索引类型。相对于Hash索引，B+树在查找单条记录的速度上比不上Hash索引，但是因为更适合范围查询和排序等操作，所以更收客户欢迎。

***带顺序访问指针的B+Tree**

B+Tree所有索引数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。
这样做是为了提高区间查询效率，例如查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大地提高了区间查询效率。

***大大减小磁盘IO消耗***
数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次IO就可以完全载入。

为了达到这个目的，在实际实现B+Tree还需要使用如下技巧：
每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次IO

B+Tree中一次检索做多需要h-1次IO（根节点常驻内存），渐进复杂度为O(h)=O(log<sub>d</sub>N）。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率会差很多。

**1.选择索引的数据类型**
MySQL支持很多数据类型，选择合适的数据类型对性能有很大的影响。通常来说，可以遵循一下一些指导原则：

- （1）越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
- （2）简单的数据类型更好：整数类型比起字符串，处理开销更小，因为字符串更复杂。在MySQL中尽量用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
- （3）尽量避免NULL：应该指定列为NOTNUL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值

**2.选择主键类型**


==MySQL常见索引有：主键索引、唯一索引、普通索引、全文索引、组合索引==
PRIMARY KEY（主键索引） ALTER TABLE `table_name` ADD PRIMARY KEY(`col`)

UNIQUE(唯一索引） ALTER TABLE `table_name` ADD UNIQUE(`col`)

INDEX(普通索引） ALTER TABLLE `table_name` ADD INDEX index_name(`col`)

FULLTEXT(全文索引） ALTER TABLE `table_name` ADD FULLTEXT(`col`)

组合索引 ALTER TABLE `table_name` ADD INDEX index_name(`col1`,`col2`,`col3`)

==Mysql各种索引区别==
普通索引：最基本的索引，没有任何限制
唯一索引：与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值
主键索引：它是一种特殊的唯一索引，不允许含有空值
全文索引：仅可用于MyISAM表，针对较大的数据，生成全文索引很耗时耗空间
联合索引：为了更多地提高MySQL效率可建立组合索引，遵循“最左前缀”原则。创建组合索引时应该将最常用（频率）做限制条件的列放在最左边，依次递减。

联合索引的好处：覆盖索引，这一点最重要的，众所周知非主键索引会先查到主键索引的值再从主键索引上拿到想要的值。但是覆盖索引可以直接在非主键索引上拿到相应的值，减少一次查询。


## 三、简述乐观锁以及悲观锁的区别以及使用场景
## 四、简述事物的四大特性
## 五、数据库的事物隔离级别有哪些？各有哪些优缺点？
## 六、MySQL有哪些常见的存储引擎？它们的区别是什么？
## 七、简述脏读和幻读的发生场景，InnoDB是如何解决幻读的？
## 八、聚簇索引和非聚簇索引有什么区别？
## 九、什么是数据库事物，MYSQL为什么会用InnnoDB作为默认选项
## 十、简述数据库中什么情况下进行分库，什么情况下进行分表？
## 十一、简述MySQL MVCC 的实现原理
## 十二、B+树叶子节点存储的是什么数据
## 十三、MySQL中InnoDB和MyISAM的区别是什么？
## 十四、数据库如何设计索引，如何查询优化？
## 十五、什么是SQL注入攻击？如何防止这类攻击？
## 十六、简述什么是最左匹配原则

## 一、Redis如何实现分布式锁？
## 二、简述Redis持久化中RDB以及AOF方案的优缺点
## 三、简述Redis中常见类型的底层数据结构
## 四、为什么Redis在单线程下能如此快？
## 五、简述Redis的线程模型以及底层架构设计
## 六、简述Redis的过期机制和内存淘汰策略
## 七、简述Redis的哨兵机制
## 八、简述redis中如何防止缓存雪崩和缓存击穿
## 九、简述Redis中跳表的应用以及优缺点
## 十、Redis有几种数据结构？Zset是如何实现的？
## 十一、简述Redis集群配置以及基础原理
