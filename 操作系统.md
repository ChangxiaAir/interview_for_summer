# 字节跳动操作系统

## 一、进程间有哪些通信方式？
同一主机上的进程通信方式：管道，消息队列、共享内存、信号量、信号。 
网络主机间的进程通信方式：RPC（Remote Procedure Call 远程过程调用）、Socket     
- 1.管道：管道是先进先出（FIFO）的信息流，允许多个进程向管道写入数据，允许多个进程从管道读出数据。在读/写的过程中，操作系统保证数据的写入顺序和读出顺序是一致的。进程通过读写管道文件或者管道设备实现彼此之间的通信。  
匿名管道（如：ps aux | grep nginx,其中“|”就是管道的意思。“|”前面部分作为“|”后面部分的输入，很明显是单向传递的，自行创建和销毁）
```
# 读
cat < test
# 写
echo "hello world" > test
```

命名管道（mkfifo xxx,Linux下一切皆文件，通过ls -l查看创建的test）
- 2.消息队列
> 管道通信属于一股脑的输入，能不能稍微温柔点有规矩的发送消息？

可以的。消息队列在发送数据的时候，按照一个个独立单元（消息体）进行发送，其中每个消息体规定大小块，同时发送方和接收方约定好消息类型或者正文的格式。   
在管道中，其大小受限且只能承载无格式字节流的方式，而消息队列允许不同进程以消息队列的形式发送给任意的进程。   
但是当发送到消息队列的数据太大，需要拷贝的时间也就越多。所以还有其他的方式？

- 3.共享内存
> 使用消息队列可以达到不错的效果，但是如果两个进程之间需要交换比较大的数据的时候，一发一收还是不能及时的感知数据。能不能用更好的方法，双方能很快的分享数据，答：有的，共享内存。

我们知道每个进程都有自己的虚拟内存空间，不同的进程映射到不同的物理内存空间。那么我们可不可以申请一块虚拟内存地址空间，不同进程通过这块虚拟地址空间映射到相同的物理地址空间呢？这样不同进程就可以及时的感知进程都干了什么，就不需要再拷贝来拷贝去。   
我们可以通过shmget创建一份共享内存，并可以通过ipcs命令查看我们创建的共享内存。此时如果一个进程需要访问这段内存，需要将这个内存加载到自己虚拟地址空间的一个位置，让内核给他一个合法的地址。使用完毕后删除内存对象。  
那么问题来了，这么多进程都共享这块内存，如果同时都往里面写内容，难免会出现冲突的现象，比如A进程写了数字5，B进程在同样的地址写了6就直接给覆盖了，这样就不友好了，怎么办？

- 4.信号量
> 为了防止冲突，我们得有个约束或者说一种保护机制。使得同一份共享的资源只能一个进程使用，这里就出现了信号量机制。

信号量定义了两种操作，p操作和v操作，p操作为申请资源，表示某部分被使用了，其他进程暂时不能使用。v操作是归还资源的操作，告知归还了资源可以用这部分。

- 5.信号  
我们或许听说过运维或者部分开发需要7*24消逝值守（项目需要上线的时候），当然也有各种监管，告警系统，一旦出现系统资源紧张等问题就会告知开发或者运维人员，对应到操作系统中，这就是信号。    
在操作系统中，不同信号用不同的值表示，每个信号设置相应的函数，一旦进程发送某一个信号给另一个进程，另一个进程将执行相应的函数进行处理。也就是说先把可能出现的异常问题准备好，一旦信号产生就执行相应的逻辑即可。

- 6.套接字 


## 二、操作系统如何申请以及管理内存的？

主存（RAM）是一件非常重要的资源，必须要小心对待内存。虽然目前大多数内存的增长速度要比IBM的7094要快得多，但是，程序大小的增长要比内存增长还快很多。正如帕金森定律说的那样：不管存储器有多大，但是程序大小的增长速度要比内存容量的增长速度要快得多。下面就来探讨一下操作系统是如何创建内存并管理它们的。    
经过多年的探讨，人们提出了一种分层存储器体系，下面是分层体系的分类：
![存储层次结构](https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2EwOWUxM2QyODNlZDRmOGJhNzQ3YWNiZWMwNGU0ODA5?x-oss-process=image/format,png)
顶层的存储器速度最高，但是容量最小，成本非常高，层次结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜。   
操作系统中管理内存层次结构的部分称为内存管理器，他的主要工作是有效的管理内存，记录哪些内存是正在使用的，在进程需要时分配内存以及在进程完成时回收内存。   

下面对不同的内存管理模型进行探讨，从简单到复杂，由于最低级别的缓存是由硬件进行管理的，所以我们主存模型和如何对主存进行管理。

#### 无存储器对象
最简单的存储器抽象是没有存储。早期计算机都没有存储器抽象。每一个程序都直接访问物理内存
## 三、简述select、poll、epoll的使用场景以及区别，epoll中水平触发以及边缘触发有什么不同？
## 四、操作系统中，虚拟地址与物理地址之间如何映射？
## 五、进程和线程之间的区别？
进程是程序的一次执行过程，是程序在执行过程中的分配和管理资源的基本单位，每个进程都有自己的地址空间。特征是动态性、并发性、独立性、异步性、结构性。状态有：运行、就绪、阻塞、创建、结束。

线程是CPU调度和分配的基本单位，他可以和同一进程下其他线程共享全部资源。

根本区别：进程是操作系统资源调度的基本单位，线程是任务的调度执行的基本单位。
## 六、简述操作系统中的缺页中断
## 七、什么时候会由用户态陷入内核态
内核态：CPU可以访问内存所有数据，包括外围设备，例如硬盘、网卡。CPU也可以将自己从一个程序切换为另一个程序。    
用户态：只能受限的访问内存，且不允许访问外围设备。占用CPU的能力被剥夺，CPU资源可以被其他程序获取。    

为什么需要用户态和内核态？ 
由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络，CPU划分出两个权限等级：用户态和内核态。   
用户态与内核态的转换  
所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情，例如从硬盘读取数据，或者从键盘获取输入等。而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作。这时需要一个这样的机制：用户态切换到内核态，但是不能控制在内核中执行的指令。
## 八、简述自旋锁与互斥锁的使用场景
## 九、简述mmap的使用场景以及原理
## 十、线程间有哪些通信方式？
- 1.锁机制：包括互斥锁、条件变量、读写锁、自旋锁
- 2.信号量机制
- 3.信号机制

线程间的通信目的主要是用于线程同步，所以县城没有像进程通信中的用于数据交换的通信机制。
## 十一、两个线程交替打印一个共享变量
```python
from threading import Thread, Lock

lock=lock()
count=0
def even(m):
  global count
  while count<=10:
    if count%2 == 0:
      with m:
        print(count)
        count+=1
    else:
      continue

def odd(m):
  global count
  while count<=9:
    if count%2 ==1:
      with m:
        print(count)
        count+=1
    else:
      continue
      
t_even = Thread(target=even,args=(lock,)).start()
t_odd = Thread(target=odd,args=(lock,)).start()
```
## 十二、简述Linux进程调度的算法
- 1.先来先服务算法
- 2.短作业优先算法
- 3.时间片轮转算法
- 4.多级反馈队列调度算法
- 5.优先权调度算法

[操作系统中常用的进程调度算法](https://blog.csdn.net/fuzhongmin05/article/details/55802925)


## 十三、Linux下查看端口被哪个进程占用？
lsof -i
netstat -tunlp

切换到root（临时sudo -i  退出exit）

[Linux如何查看端口被哪个进程占用](https://www.cnblogs.com/fps2tao/p/10042553.html)
## 十四、简述Linux零拷贝的原理
## 十五、什么情况下，进程会进行切换
## 十六、简述traceroute命令的原理

# 腾讯操作系统
## 一、进程和线程之间有什么区别
## 二、进程间有哪些通信方式
## 三、简述select、poll、epoll的使用场景以及区别，epoll中水平触发以及边缘触发有什么不同？
## 四、简述Linux进程调度的算法
## 五、操作系统是如何申请以及管理内存的
## 六、简述Linux的用户态与内核态，什么时候会进入内核态？
## 七、线程间有哪些通信方式
## 八、简述操作系统中的缺页中断
## 九、简述同步与异步的区别，阻塞与非阻塞的区别
## 十、简述操作系统如何进行内存管理
## 十一、简述几个常用的Linux命令以及它们的功能
## 十二、什么时候会由用户态陷入内核态
## 十三、BIO、NIO有什么区别？怎么判断写文件时Buffer已经写满？简述Linux的IO模型
## 十四、简述操作系统中的malloc的实现原理
## 十五、Linux下如何查看端口被哪个进程占用
## 十六、Linux中虚拟内存和物理内存有什么区别？有什么优点？
## 进程空间从高位到低位都有些什么
